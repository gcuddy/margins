generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["orderByNulls", "fullTextSearch", "fullTextIndex", "extendedWhereUnique"]
}

datasource db {
    provider     = "mysql"
    url          = env("DATABASE_URL")
    relationMode = "prisma"
}

// model AnnotationBody {
// }

/// State represents the state of an Annotation. The defaults are "Inbox", "Next", "Later", and "Archive".
model State {
    id              Int          @id @default(autoincrement())
    /// Whether or not this state represents things to be looked at later.
    read_later      Boolean
    /// The name of the state
    name            String
    /// State's UI color as a hex string
    color           String?
    /// The type of the state
    type            Location
    /// The position of the state
    position        Float
    description     String?
    user            User         @relation("user", fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
    userId          String
    defaultRelation User?        @relation("default_state")
    // only ONE should be true — how can we enforce this? or should we instead hold a default_state_id under user?
    default         Boolean      @default(false)
    createdAt       DateTime     @default(now())
    updatedAt       DateTime     @updatedAt
    Annotation      Annotation[]

    @@index([userId])
}

model Annotation {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // body is used for: page note when type is bookmarking, or annotation when type is highlight/annotation
    // maybe Json  see model. Different possibilties (.e.g. image, video, sound,  — but i think for now we'll just stick with representing it as text. can always rewrite this later if we need to)
    //TODO: motivation, purpose, and expanded target/body. again, see complete examlpe in annotation model
    // for saving structured data
    body Json?

    tags      Taggings[]
    type      AnnotationType
    readLater Boolean        @default(true)
    private   Boolean        @default(true)
    target    Json? // see https://www.w3.org/TR/annotation-model/#complete-example — using hypothes.is model of multiple selectors?
    entryId   Int?
    entry     Entry?         @relation(fields: [entryId], references: [id])
    metadata  EntryData      @relation(fields: [entryDataId], references: [id])
    // todo: data (i.e. custom title and metadata)

    /// The state of the annotation. Only relevant if it's a bookmark. (I think.)
    state   State? @relation(fields: [stateId], references: [id])
    stateId Int?
    // stateId 0 = inbox

    /// An annotation will have a parent when it's a type/annotation (i.e. an annotation on a bookmark) or a reply
    parent   Annotation?  @relation("references", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
    parentId Int?
    children Annotation[] @relation("references")

    /// The "soft delete" time. Deletions are cleared after 30 days.
    deleted DateTime?
    creator User      @relation(fields: [userId], references: [id])
    userId  String

    sortOrder   Float            @default(-1000)
    // refs
    collections CollectionItems?
    favorite    Favorite?

    // @@unique([userId, entryId]) <- this doesn't quite make sense, because of cihldren. i want it to be when type is bookmark. maybe sql? or maybe children don't get entryid?
    // again, could solve this by having a sepaerate model or something
    entryDataId Int

    @@index([entryId])
    @@index([userId])
    @@index([stateId])
    @@index([parentId])
}

// this loosely corresponds to the web annotation motivation/purpose section, but modified for our use
enum AnnotationType {
    bookmark
    annotation
    reply
}

enum Location {
    inbox
    soon
    later
    archive
}

model Entry {
    data         EntryData?
    context      String? // uri of item it's saved from. not sure if it makes sense for this to be on Document or on Annotation.
    createdAt    DateTime           @default(now())
    author       String?
    location     Location? // only relevant if read later?
    // this is maybe the "real" title but also stored in data for uesrs
    title        String?
    type         DocumentType
    updatedAt    DateTime           @updatedAt
    id           Int                @id @default(autoincrement())
    //todo: expand to fingerprint and url, doi, etc. maybe can all fit in this string, i'm not sure
    uri          String?            @unique
    // if it's a rss
    html         String?            @db.LongText
    text         String?            @db.LongText
    image        String?
    guid         String?            @unique //@ unique?
    wordCount    Int?
    summary      String?
    media        Json?
    published    DateTime?
    updated      DateTime?
    feedId       Int?
    feed         Feed?              @relation(fields: [feedId], references: [id])
    interactions EntryInteraction[]
    EntryMedia   EntryMedia[]
    annotations  Annotation[]

    @@index([feedId])
}

model EntryData {
    id          Int          @id @default(autoincrement())
    html        String?      @db.LongText
    text        String?      @db.LongText
    image       String?
    wordCount   Int?
    summary     String?
    media       EntryMedia[]
    published   DateTime?
    updated     DateTime?
    createdAt   DateTime     @default(now())
    updatedAt   DateTime     @updatedAt
    document    Entry        @relation(fields: [documentUri], references: [uri])
    documentUri String       @unique

    // TODO: pdf, image, etc

    // these *can* belong to a user, but don't have to
    user       User?        @relation(fields: [userId], references: [id])
    userId     String?
    Annotation Annotation[]

    @@index([documentUri])
}

model EntryMedia {
    id             Int       @id @default(autoincrement())
    url            String?
    size           Int?
    duration       Int?
    type           String? //mime type
    title          String?
    DocumentData   EntryData @relation(fields: [documentDataId], references: [id])
    documentDataId Int
    Entry          Entry?    @relation(fields: [entryId], references: [id])
    entryId        Int?

    @@index([documentDataId])
}

// tweet, reddit post, bandcamp - these would probably be classified under bookmark, but we could add more types if we want to
enum DocumentType {
    article
    rss
    pdf
    epub
    bookmark
    image
    video
    audio
}

// @deprecated
model Article {
    id             Int       @id @default(autoincrement())
    title          String    @db.Text
    content        String?   @db.LongText
    textContent    String?   @db.LongText
    author         String?
    private        Boolean   @default(true)
    createdAt      DateTime  @default(now())
    updatedAt      DateTime  @updatedAt
    readProgress   Float?    @default(0)
    slug           String?
    url            String?
    siteName       String?
    colorHash      String?
    date           DateTime?
    image          String?   @db.Text
    wordCount      Int?
    starred        Boolean   @default(false)
    css            String?
    description    String?   @db.Text // This shouldn't be that long, but we'll use Text to make sure
    wiki           String?
    classification String?
    pdf            Boolean?
    html           String?
    readLater      Boolean   @default(true)
    bookmark       Boolean   @default(false)
    position       Int       @default(0) //@unique - figure this out
    trash          Boolean   @default(false)
    location       String    @default("INBOX")
    // Bookmark       Bookmark?
    context        Context?
    type           Int       @default(0) // 0 = text, 1 = audio, 2 = video
    favorite       Favorite?
    user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId         String

    @@unique([userId, url])
    @@index([userId])
    @@map("Article")
}

model Context {
    id          Int      @id @default(autoincrement())
    url         String   @unique
    description String?
    createdAt   DateTime @default(now())
    articleId   Int?     @unique
    Article     Article? @relation(fields: [articleId], references: [id])
}

model Collection {
    id          Int               @id @default(autoincrement())
    name        String
    private     Boolean           @default(true)
    icon        Json?
    user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String
    description String?
    createdAt   DateTime          @default(now())
    updatedAt   DateTime          @updatedAt
    items       CollectionItems[]
    // order       Json // array[] of item ids in order.... /??

    @@unique([userId, name])
    @@index([userId])
}

model CollectionItems {
    id           Int                @id @default(autoincrement())
    collection   Collection         @relation(fields: [collectionId], references: [id])
    collectionId Int
    position     Int                @default(0)
    type         CollectionItemType // probably not needded
    createdAt    DateTime           @default(now())
    updatedAt    DateTime           @updatedAt
    articleId    Int?               @unique
    annotationId Int?               @unique
    annotation   Annotation?        @relation(fields: [annotationId], references: [id])

    @@index([collectionId])
    @@index([articleId])
}

enum CollectionItemType {
    ARTICLE
    BOOKMARK
    COLLECTION
}

enum FetchFrequency {
    realtime
    daily
    weekly
    rnthly
}

model Feed {
    id Int @id @default(autoincrement())

    // itunes_id is actually an Int, so you can set it directly — will be deprecating this soon
    itunes_id String? @unique
    //

    feedUrl       String         @unique
    title         String?
    link          String?
    creator       String?
    description   String?        @db.Text
    lastBuildDate DateTime?
    imageUrl      String?        @db.Text
    entries       Entry[]
    tags          Taggings[]
    podcast       Boolean        @default(false)
    createdAt     DateTime       @default(now()) /// @zod.custom(z.string())
    updatedAt     DateTime       @updatedAt /// @zod.custom(z.string())
    favorite      Favorite?
    active        Boolean        @default(true)
    /// Velocity refers to the amount of times a feed is published per day.
    velocity      Int?
    subscriptions Subscription[]
}

model Subscription {
    id        Int      @id @default(autoincrement())
    feed      Feed     @relation(fields: [feedId], references: [id])
    feedId    Int
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    createdAt DateTime @default(now()) /// @zod.custom(z.string())
    updatedAt DateTime @updatedAt /// @zod.custom(z.string())
    title     String

    @@unique([userId, feedId])
    // kind - some sort of enum of rss or podcast or tweet i think (maybe unnnecessary because that data is stored on Feed)
    // custom metadata here: view mode, status, etc
    // fetchFrequency FetchFrequency @default(realtime)
    @@index([userId])
    @@index([feedId])
}

model History {
    id            Int               @id @default(autoincrement())
    createdAt     DateTime          @default(now())
    interaction   EntryInteraction? @relation(fields: [interactionId], references: [id])
    interactionId Int?

    @@index([interactionId])
}

model EntryInteraction {
    id         Int      @id @default(autoincrement())
    createdAt  DateTime @default(now())
    updatedAt  DateTime @updatedAt
    is_read    Boolean? @default(false)
    progress   Float?   @default(0)
    finished   Boolean? @default(false)
    document   Entry    @relation(fields: [documentId], references: [id])
    documentId Int
    userId     String
    user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    // TODO: choose either history model (array of each interaction, or just simple updating last_viewed)
    history          History[]
    last_viewed      DateTime  @default(now())
    last_annotated   DateTime  @default(now())
    last_interaction DateTime  @default(now())

    @@unique([documentId, userId])
    @@index([documentId])
    @@index([userId])
}

model Tag {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    favorite    Favorite?
    // TODO: maybe move viewoptions to ViewPreference
    viewOptions Json?
    user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String
    taggings    Taggings[]

    @@unique([name, userId])
    @@index([userId])
}

model Taggings {
    id           Int         @id @default(autoincrement())
    //   TODO: represents tags on documents and feeds
    tag          Tag         @relation(fields: [tagId], references: [id])
    tagId        Int
    user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId       String
    feed         Feed?       @relation(fields: [feedId], references: [id])
    feedId       Int?
    annotation   Annotation? @relation(fields: [annotationId], references: [id])
    annotationId Int?

    // do those make sense?
    @@unique([annotationId, userId, tagId])
    @@unique([feedId, userId, tagId])
    @@index([userId])
    @@index([tagId])
    @@index([feedId])
    @@index([annotationId])
    @@index([userId, tagId])
    @@index([userId, feedId])
    @@index([userId, annotationId])
}

model SmartList {
    id          Int       @id @default(autoincrement())
    name        String    @unique
    filter      Json
    viewOptions Json?
    // conditions SmartListCondition[]
    favorite    Favorite?
}

model User {
    id               String             @id @unique @default(cuid())
    provider_id      String             @unique
    hashed_password  String?
    session          Session[]
    createdAt        DateTime           @default(now())
    updatedAt        DateTime           @updatedAt
    //
    email            String             @unique
    username         String             @unique
    //
    // self relation
    followedBy       User[]             @relation("UserFollows")
    following        User[]             @relation("UserFollows")
    //
    interactions     EntryInteraction[]
    favorites        Favorite[]
    articles         Article[]
    favoriteFolders  FavoriteFolder[]
    collections      Collection[]
    annotations      Annotation[]
    subscriptions    Subscription[]
    documentData     EntryData[]
    stylesheets      Stylesheet[]
    states           State[]            @relation("user")
    default_state    State?             @relation("default_state", references: [id], fields: [default_state_id])
    default_state_id Int?               @unique
    taggings         Taggings[]
    tags             Tag[]

    @@map("user")
}

model Session {
    id           String @id @unique
    user_id      String
    expires      BigInt
    idle_expires BigInt
    user         User   @relation(references: [id], fields: [user_id], onDelete: Cascade)

    @@index([user_id])
    @@map("session")
}

model FavoriteFolder {
    id        Int        @id @default(autoincrement())
    name      String
    createdAt DateTime   @default(now())
    updatedAt DateTime   @updatedAt
    userId    String
    user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    favorites Favorite[]
}

// either Interaction or Favorite
//  see https://cloud.prisma.io/gcuddy/prisma-data-test/production/schema
model Favorite {
    id               Int             @id @default(autoincrement())
    createdAt        DateTime        @default(now())
    updatedAt        DateTime        @updatedAt
    userId           String
    user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
    // count      Int      @default(1)
    // one of: article, tag, list, or smart list
    articleId        Int?            @unique
    article          Article?        @relation(fields: [articleId], references: [id])
    tagId            Int?            @unique
    tag              Tag?            @relation(fields: [tagId], references: [id])
    rssId            Int?            @unique
    rss              Feed?           @relation(fields: [rssId], references: [id])
    smartListId      Int?            @unique
    smartList        SmartList?      @relation(fields: [smartListId], references: [id])
    folder           FavoriteFolder? @relation(fields: [favoriteFolderId], references: [id])
    favoriteFolderId Int?
    annotation       Annotation?     @relation(fields: [annotationId], references: [id])
    annotationId     Int?            @unique

    @@index([userId])
    @@index([articleId])
    @@index([tagId])
    @@index([rssId])
    @@index([smartListId])
    @@index([favoriteFolderId])
    @@index([annotationId])
}

//todo: user entry/
model UserEntry {
    id         Int          @id @default(autoincrement())
    // this model connects a user with an entry, storing their own custom metadata
    Stylesheet Stylesheet[]
}

model Stylesheet {
    id          Int        @id @default(autoincrement())
    domain      String
    css         String     @db.MediumText
    entry       UserEntry? @relation(fields: [userEntryId], references: [id])
    userEntryId Int?
    user        User       @relation(fields: [userId], references: [id])
    userId      String

    @@index([userEntryId])
    @@index([userId])
}
