generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByNulls", "fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider          = "postgresql"
  url               = env("HEROKU_URL")
  shadowDatabaseUrl = env("HEROKU_SHADOW_URL")
}

model Article {
  id             Int              @id @default(autoincrement())
  title          String
  content        String
  textContent    String
  author         String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  readProgress   Float            @default(0)
  url            String           @unique
  siteName       String?
  colorHash      String?
  date           DateTime
  image          String
  wordCount      Int
  starred        Boolean          @default(false)
  css            String?
  description    String?
  wiki           String?
  classification String?
  pdf            Boolean?
  html           String?
  position       Int              @default(0) //@unique - figure this out
  trash          Boolean          @default(false)
  location       String           @default("INBOX")
  annotations    Annotation[]
  Bookmark       Bookmark?
  context        Context?
  highlights     Highlight[]
  Highlight2     Highlight2[]
  ListItem       ListItem?
  media          Media?
  tags           Tag[]
  favorite       Favorite?
  RssInteraction RssInteraction[]
}

model Bookmark {
  id          Int       @id @default(autoincrement())
  url         String    @unique
  title       String
  description String?
  createdAt   DateTime  @default(now())
  html        String
  articleId   Int?      @unique
  contextId   Int
  article     Article?  @relation(fields: [articleId], references: [id])
  context     Context   @relation(fields: [contextId], references: [id])
  ListItem    ListItem?
  tags        Tag[]
}

model Context {
  id          Int        @id @default(autoincrement())
  url         String     @unique
  description String?
  createdAt   DateTime   @default(now())
  articleId   Int?       @unique
  Article     Article?   @relation(fields: [articleId], references: [id])
  Bookmark    Bookmark[]
}

model List {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  items       ListItem[]
}

model ListItem {
  id           Int        @id @default(autoincrement())
  listId       Int
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  articleId    Int?       @unique
  bookmarkId   Int?       @unique
  highlightId  String?    @unique
  annotationId Int?       @unique
  type         String
  article      Article?   @relation(fields: [articleId], references: [id])
  bookmark     Bookmark?  @relation(fields: [bookmarkId], references: [id])
  highlight    Highlight? @relation(fields: [highlightId], references: [id])
  list         List       @relation(fields: [listId], references: [id])
}

model Media {
  id          Int     @id @default(autoincrement())
  url         String
  title       String
  description String
  duration    Int
  type        String
  articleId   Int     @unique
  article     Article @relation(fields: [articleId], references: [id])
}

model Highlight {
  id            String    @id @default(cuid())
  articleId     Int
  nonTextNodes  String?
  text          String
  sanitizedHtml String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  flagged       Boolean   @default(false)
  startMetaId   Int       @unique
  endMetaId     Int       @unique
  article       Article   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  endMeta       DomMeta   @relation("endMeta", fields: [endMetaId], references: [id])
  startMeta     DomMeta   @relation("startMeta", fields: [startMetaId], references: [id])
  ListItem      ListItem?
}

model DomMeta {
  id             Int        @id @default(autoincrement())
  parentTagName  String
  parentIndex    String
  textOffset     Int
  endHighlight   Highlight? @relation("endMeta")
  startHighlight Highlight? @relation("startMeta")
}

model Annotation {
  id         Int      @id @default(autoincrement())
  target     Json // see https://www.w3.org/TR/annotation-model/#complete-example — using hypothes.is model of multiple selectors?
  body       String? // maybe Json  see model. Different possibilties (.e.g. image, video, sound,  — but i think for now we'll just stick with representing it as text. can always rewrite this later if we need to)
  //TODO: motivation, purpose, and expanded target/body. again, see complete examlpe in annotation model
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  flagged    Boolean  @default(false)
  motivation String?
  articleId  Int
  article    Article  @relation(fields: [articleId], references: [id])
}

model RssFeed {
  id            Int           @id @default(autoincrement())
  feedUrl       String        @unique
  title         String?
  link          String?
  description   String?
  lastBuildDate DateTime?
  imageUrl      String?
  items         RssFeedItem[]
  tag           RssFeedTag[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  favorite      Favorite?
  // todo: itunes

  // this should be unique per user
  // @@unique([feedUrl])
  RssInteraction RssInteraction[]
}

model RssInteraction {
  id        Int      @id @default(autoincrement())
  articleId Int
  rssFeedId Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  article   Article  @relation(fields: [articleId], references: [id])
  rssFeed   RssFeed  @relation(fields: [rssFeedId], references: [id])
  is_read   Boolean  @default(false)
  podcast   Boolean  @default(false)
  played    Boolean  @default(false)
}

model RssFeedItem {
  id             Int               @id @default(autoincrement())
  uuid           String            @unique
  is_read        Boolean           @default(false)
  starred        Boolean           @default(false)
  podcast        Boolean           @default(false)
  played         Boolean           @default(false)
  link           String?
  guid           String?
  title          String?
  contentSnippet String?
  pubDate        DateTime?
  creator        String?
  summary        String?
  author         String?
  content        String?
  isoDate        DateTime?
  categories     String[]
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  rssFeedId      Int
  RssFeed        RssFeed           @relation(fields: [rssFeedId], references: [id])
  enclosure      RssFeedEnclosure?
}

model RssFeedEnclosure {
  id     Int         @id @default(autoincrement())
  url    String?
  length Int?
  type   String?
  feed   RssFeedItem @relation(fields: [feedId], references: [id])
  feedId Int         @unique
}

model RssFeedTag {
  id    Int       @id @default(autoincrement())
  name  String    @unique
  feeds RssFeed[]
}

model Tag {
  id            Int       @id @default(autoincrement())
  name          String    @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  bookmarkId    Int?
  rssFeedItemId String?
  Bookmark      Bookmark? @relation(fields: [bookmarkId], references: [id])
  articles      Article[]
  favorite      Favorite?
}

model Css {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  domain    String   @unique
  css       String?
}

model StringCondition {
  id       Int     @id @default(autoincrement())
  contains Boolean
  value    String
}

model SmartListCondition {
  id          Int     @id @default(autoincrement())
  smartListId Int?
  any         Boolean
  title       String?
}

model SmartList {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  filter      Json
  viewOptions Json?
  // conditions SmartListCondition[]
  favorite    Favorite?
}

model Target {
  id         Int       @id @default(autoincrement())
  source     String
  selector   Selector? @relation(fields: [selectorId], references: [id])
  selectorId Int       @unique
}

model Selector {
  id   Int    @id @default(autoincrement())
  type String // one of: TextQuoteSelector, TextPositionSelector, cssSelector, rangeselector, etc. (would use enum but they cause problems. zod/middleware will help us out)

  target Target?

  // TEXTQUOTESELECTOR (use zod/middleware to enforce this)
  exact  String? //* actually required
  prefix String?
  suffix String?

  // text position slector (all required)
  start Int?
  end   Int?

  // css selector (if type === 'cssSelector', this is required)
  value String?

  //range selector
  // startSelectorId Int?
  // startSelector   Selector? @relation("startSelector", fields: [startSelectorId], references: [id])
  // endSelectorId   Int?
  // endSelector     Selector? @relation("endSelector", fields: [endSelectorId], references: [id])

  // A selector can be refined by another selector
  refinedById Int?      @unique
  refinedBy   Selector? @relation("refinedBy", fields: [refinedById], references: [id])
  refines     Selector? @relation("refinedBy")

  //range selector
  // startSelectorId Int?
  // startSelector   Selector? @relation("startSelector", fields: [startSelectorId], references: [id])
  // endSelectorId   Int?
  // endSelector     Selector? @relation("endSelector", fields: [endSelectorId], references: [id])

  // refinedBySelectorId Int?
  // refinedBy Selector? @relation("refinedBy", fields: [refinedBySelectorId], references: [id])
}

model TextPositionSelector {
  id               Int                @id @default(autoincrement())
  start            Int
  end              Int
  AnnotationTarget AnnotationTarget[]
}

model TextQuoteSelector {
  id               Int                @id @default(autoincrement())
  exact            String
  prefix           String?
  suffix           String?
  type             String             @default("TextQuoteSelector")
  AnnotationTarget AnnotationTarget[]
}

// model RangeSelector {
//   id               Int                @id @default(autoincrement())
//   startSelectorId  Int                @unique
//   endSelectorId    Int                @unique
//   textOffset       Int
//   endSelector      Selector           @relation("end", fields: [endSelectorId], references: [id], map: "end_selector")
//   startSelector    Selector           @relation("start", fields: [startSelectorId], references: [id], map: "start_selector")
//   AnnotationTarget AnnotationTarget[]
// }

model AnnotationTarget {
  id                     Int                   @id @default(autoincrement())
  source                 String
  selectors              Json
  rangeSelectorId        Int?
  textPositionSelectorId Int?
  textQuoteSelectorId    Int
  // rangeSelector          RangeSelector?        @relation(fields: [rangeSelectorId], references: [id])
  textPosition           TextPositionSelector? @relation(fields: [textPositionSelectorId], references: [id])
  textQuote              TextQuoteSelector     @relation(fields: [textQuoteSelectorId], references: [id])
  Highlight2             Highlight2[]
}

model Highlight2 {
  id            Int              @id @default(autoincrement())
  articleId     Int
  targetId      Int
  text          String
  sanitizedHtml String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  flagged       Boolean          @default(false)
  article       Article          @relation(fields: [articleId], references: [id], onDelete: Cascade)
  target        AnnotationTarget @relation(fields: [targetId], references: [id])
}

model User {
  id        Int        @id @default(autoincrement())
  name      String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  favorites Favorite[]
}

// either Interaction or Favorite
//  see https://cloud.prisma.io/gcuddy/prisma-data-test/production/schema
// let's try Interaction
model Favorite {
  id          Int        @id @default(autoincrement())
  position    Float      @unique
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  userId      Int?
  user        User?      @relation(fields: [userId], references: [id])
  // count      Int      @default(1)
  // one of: article, tag, list, or smart list
  articleId   Int?       @unique
  article     Article?   @relation(fields: [articleId], references: [id])
  tagId       Int?       @unique
  tag         Tag?       @relation(fields: [tagId], references: [id])
  rssId       Int?       @unique
  rss         RssFeed?   @relation(fields: [rssId], references: [id])
  smartListId Int?       @unique
  smartList   SmartList? @relation(fields: [smartListId], references: [id])
}
