generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["orderByNulls", "fullTextSearch", "fullTextIndex", "extendedWhereUnique", "fieldReference"]
}

generator zod {
    provider = "prisma-zod-generator"
    output   = "../src/lib/zod"
}

datasource db {
    provider     = "mysql"
    url          = env("DATABASE_URL")
    relationMode = "prisma"
}

// model AnnotationBody {
// }

/// State represents the state of an Annotation. The defaults are "Inbox", "Next", "Later", and "Archive".
model State {
    id              Int        @id @default(autoincrement())
    /// Whether or not this state represents things to be looked at later.
    read_later      Boolean
    /// The name of the state
    name            String
    /// State's UI color as a hex string
    color           String?
    /// The type of the state
    type            Location
    /// The position of the state
    position        Float
    description     String?
    user            User       @relation("user", fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
    userId          String
    defaultRelation User?      @relation("default_state")
    // only ONE should be true — how can we enforce this? or should we instead hold a default_state_id under user?
    default         Boolean    @default(false)
    createdAt       DateTime   @default(now())
    updatedAt       DateTime   @updatedAt
    bookmarks       Bookmark[]

    @@index([userId])
}

model Bookmark {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    context   Json? // should be uri string / schema that looks like: {entryId?: number; url: string; feedId?: number; }. or use model? hm.
    // really should be required, but there's some nasty enforcements if it is
    entry     Entry?   @relation(fields: [uri, entryId], references: [uri, id])
    uri       String?  @unique
    entryId   Int?     @unique
    user      User     @relation(fields: [userId], references: [id])
    userId    String
    sortOrder Int?     @default(0)
    is_read   Boolean  @default(false)
    progress  Float    @default(0)
    // we store custom data here too, in case the user has their own data somehow.
    // title     String?
    // author    String?
    // html      String?   @db.LongText
    // text      String?
    // image     String?
    // published DateTime?
    data      Json?
    //...etc

    /// can we store interaction data here too?
    // is_read Boolean etc
    // or should it be a 1-1 to an Interaction/History model?
    // I think interaction model makes sense because interactions exist on *entries* still.

    /// The state in which this bookmark is. A state of null indicates it's been interacted with but not saved.
    state   State? @relation(fields: [stateId], references: [id])
    stateId Int?

    private       Boolean           @default(true)
    tags          Tagging[]
    collections   CollectionItems[]
    interaction   Interaction?      @relation(fields: [interactionId], references: [id])
    interactionId Int?              @unique
    favorite      Favorite?
    favoriteId    Int?
    annotations   Annotation[]

    deleted DateTime?

    @@index([uri, entryId])
    @@index([uri])
    @@index([userId])
    @@index([stateId])
    @@index([userId, stateId])
    @@index([interactionId, stateId, uri])
}

model Annotation {
    id        Int            @id @default(autoincrement())
    createdAt DateTime       @default(now())
    updatedAt DateTime       @updatedAt
    // body is used for: page note when type is bookmarking, or annotation when type is highlight/annotation
    // maybe Json  see model. Different possibilties (.e.g. image, video, sound,  — but i think for now we'll just stick with representing it as text. can always rewrite this later if we need to)
    //TODO: motivation, purpose, and expanded target/body. again, see complete examlpe in annotation model
    // for saving structured data
    body      Json?
    tags      Tagging[]
    type      AnnotationType
    private   Boolean        @default(true)
    target    Json? // see https://www.w3.org/TR/annotation-model/#complete-example — using hypothes.is model of multiple selectors?
    entry     Entry?         @relation(fields: [entryId], references: [id])
    entryId   Int?
    // TODO: should an annotation be associated with an entry, an a bookmark, or both, or neither??

    /// An annotation will have a parent when it's a reply
    parent   Annotation?  @relation("references", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
    parentId Int?
    children Annotation[] @relation("references")

    /// The "soft delete" time. Deletions are cleared after 30 days.
    deleted DateTime?
    creator User      @relation(fields: [userId], references: [id])
    userId  String

    sortOrder   Float            @default(0)
    // refs
    collections CollectionItems?
    favorite    Favorite?
    bookmark    Bookmark?        @relation(fields: [bookmarkId], references: [id])
    bookmarkId  Int?

    // @@unique([userId, entryId]) <- this doesn't quite make sense, because of cihldren. i want it to be when type is bookmark. maybe sql? or maybe children don't get entryid? <- indeed we are now!s
    // again, could solve this by having a sepaerate model or something <- indeed we are now!s
    @@index([entryId])
    @@index([userId])
    @@index([parentId])
    @@index([bookmarkId])
}

// this loosely corresponds to the web annotation motivation/purpose section, but modified for our use
enum AnnotationType {
    bookmark
    note
    annotation
    reply
}

enum Location {
    inbox
    soon
    later
    archive
}

model Entry {
    data         EntryData[]
    createdAt    DateTime      @default(now())
    author       String?
    location     Location? // only relevant if read later?
    // this is maybe the "real" title but also stored in data for uesrs
    title        String?
    type         DocumentType  @default(article)
    updatedAt    DateTime      @updatedAt
    id           Int           @id @default(autoincrement())
    //todo: expand to fingerprint and url, doi, etc. maybe can all fit in this string, i'm not sure
    uri          String?       @unique
    // if it's a rss
    html         String?       @db.LongText
    text         String?       @db.LongText
    image        String?       @db.VarChar(2083)
    guid         String?       @unique //@ unique?
    /// Original represents original data (html, title) in case we've re-download and/or changes...?
    original     Json?
    wordCount    Int?
    siteName     String?
    summary      String?
    media        Json?
    published    DateTime?
    updated      DateTime?
    feedId       Int?
    feed         Feed?         @relation(fields: [feedId], references: [id])
    interactions Interaction[]
    EntryMedia   EntryMedia[]
    annotations  Annotation[]
    bookmarks    Bookmark[]
    // Tagging      Tagging[]
    // eventually move this to explicit due to planetscale indexing?
    tags         Tag[]
    entrytags    EntryTag[]
    context      Context[]

    @@unique([uri, id])
    @@index([feedId])
    @@index([id, published, createdAt])
}

/// Represents user-downloaded/defined data for an entry
model EntryData {
    id        Int          @id @default(autoincrement())
    html      String?      @db.LongText
    text      String?      @db.LongText
    custom    Json?
    image     String?
    wordCount Int?
    summary   String?
    media     EntryMedia[]
    data      Json?
    published DateTime?
    updated   DateTime?
    createdAt DateTime     @default(now())
    updatedAt DateTime     @updatedAt
    entry     Entry        @relation(fields: [entryId], references: [id])
    entryId   Int          @unique

    // TODO: pdf, image, etc

    // these *can* belong to a user, but don't have to
    user   User   @relation(fields: [userId], references: [id])
    userId String

    @@unique([entryId, userId])
    @@index([entryId])
    @@index([userId])
}

model EntryMedia {
    id             Int       @id @default(autoincrement())
    url            String?
    size           Int?
    duration       Int?
    type           String? //mime type
    title          String?
    DocumentData   EntryData @relation(fields: [documentDataId], references: [id])
    documentDataId Int
    Entry          Entry?    @relation(fields: [entryId], references: [id])
    entryId        Int?

    @@index([documentDataId])
    @@index([entryId])
}

// tweet, reddit post, bandcamp - these would probably be classified under bookmark, but we could add more types if we want to
enum DocumentType {
    article
    rss
    pdf
    epub
    bookmark
    image
    video
    audio
}

// @deprecated
model Article {
    id             Int       @id @default(autoincrement())
    title          String    @db.Text
    content        String?   @db.LongText
    textContent    String?   @db.LongText
    author         String?
    private        Boolean   @default(true)
    createdAt      DateTime  @default(now())
    updatedAt      DateTime  @updatedAt
    readProgress   Float?    @default(0)
    slug           String?
    url            String?
    siteName       String?
    colorHash      String?
    date           DateTime?
    image          String?   @db.Text
    wordCount      Int?
    starred        Boolean   @default(false)
    css            String?
    description    String?   @db.Text // This shouldn't be that long, but we'll use Text to make sure
    wiki           String?
    classification String?
    pdf            Boolean?
    html           String?
    readLater      Boolean   @default(true)
    bookmark       Boolean   @default(false)
    position       Int       @default(0) //@unique - figure this out
    trash          Boolean   @default(false)
    location       String    @default("INBOX")
    // Bookmark       Bookmark?
    type           Int       @default(0) // 0 = text, 1 = audio, 2 = video
    user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId         String
    favoriteId     Int?

    @@unique([userId, url])
    @@index([userId])
    @@map("Article")
}

model ContextNode {
    /// context node refers to a source or referrer — for example, a Discord Server, or another user
    id          String  @id @default(cuid())
    name        String
    url         String?
    description String?

    owner  User   @relation(fields: [userId], references: [id])
    userId String

    refers_to String?

    @@index([userId])
}

model Context {
    id        Int      @id @default(autoincrement())
    createdAt DateTime @default(now())

    user   User   @relation(fields: [userId], references: [id])
    userId String

    // entry?
    entry   Entry? @relation(fields: [entryId], references: [id])
    entryId Int?

    // feed?
    feed   Feed? @relation(fields: [feedId], references: [id])
    feedId Int?

    // url?
    url String?

    // just a description?
    description String?

    @@index([userId])
    @@index([entryId])
    @@index([feedId])
}

model Collection {
    id          Int               @id @default(autoincrement())
    name        String
    private     Boolean           @default(true)
    icon        Json?
    user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String
    description String?
    createdAt   DateTime          @default(now())
    updatedAt   DateTime          @updatedAt
    items       CollectionItems[]
    // order       Json // array[] of item ids in order.... /??

    @@unique([userId, name])
    @@index([userId])
}

model CollectionItems {
    id           Int                @id @default(autoincrement())
    collection   Collection         @relation(fields: [collectionId], references: [id])
    collectionId Int
    position     Int                @default(0)
    type         CollectionItemType // probably not needded
    createdAt    DateTime           @default(now())
    updatedAt    DateTime           @updatedAt
    annotationId Int?               @unique
    annotation   Annotation?        @relation(fields: [annotationId], references: [id])
    bookmark     Bookmark?          @relation(fields: [bookmarkId], references: [id])
    bookmarkId   Int?

    @@index([collectionId])
    @@index([bookmarkId])
}

enum CollectionItemType {
    ARTICLE
    BOOKMARK
    COLLECTION
}

enum FetchFrequency {
    realtime
    daily
    weekly
    rnthly
}

model Feed {
    id Int @id @default(autoincrement())

    // itunes_id is actually an Int, so you can set it directly — will be deprecating this soon
    itunes_id String? @unique
    //

    feedUrl       String         @unique
    title         String?
    link          String?
    creator       String?
    description   String?        @db.Text
    lastBuildDate DateTime?
    imageUrl      String?        @db.Text
    entries       Entry[]
    tags          Tagging[]
    podcast       Boolean        @default(false)
    createdAt     DateTime       @default(now()) /// @zod.custom(z.string())
    updatedAt     DateTime       @updatedAt /// @zod.custom(z.string())
    favorite      Favorite?
    active        Boolean        @default(true)
    /// Velocity refers to the amount of times a feed is published per day.
    velocity      Int?
    subscriptions Subscription[]
    context       Context[]
}

model Subscription {
    id        Int      @id @default(autoincrement())
    feed      Feed     @relation(fields: [feedId], references: [id])
    feedId    Int
    userId    String
    user      User     @relation(fields: [userId], references: [id])
    createdAt DateTime @default(now()) /// @zod.custom(z.string())
    updatedAt DateTime @updatedAt /// @zod.custom(z.string())
    title     String

    download_full Boolean @default(false)

    @@unique([userId, feedId])
    // kind - some sort of enum of rss or podcast or tweet i think (maybe unnnecessary because that data is stored on Feed)
    // custom metadata here: view mode, status, etc
    // fetchFrequency FetchFrequency @default(realtime)
    @@index([userId])
    @@index([feedId])
}

model Interaction {
    id        Int       @id @default(autoincrement())
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    is_read   Boolean?  @default(false)
    progress  Float?    @default(0)
    finished  Boolean?  @default(false)
    entry     Entry     @relation(fields: [entryId], references: [id])
    entryId   Int
    userId    String
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    bookmark  Bookmark?

    last_viewed      DateTime @default(now())
    last_annotated   DateTime @default(now())
    last_interaction DateTime @default(now())

    @@unique([userId, entryId])
    @@index([entryId])
    @@index([userId])
    @@map("EntryInteraction")
}

model Tag {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    favorite    Favorite?
    // TODO: maybe move viewoptions to ViewPreference
    viewOptions Json?
    user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String
    taggings    Tagging[]
    entryTags   EntryTag[]
    entries     Entry[]

    @@unique([name, userId])
    @@index([userId])
}

model EntryTag {
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    tag       Tag      @relation(fields: [tagId], references: [id])
    tagId     Int
    entry     Entry    @relation(fields: [entryId], references: [id])
    entryId   Int
    user      User     @relation(fields: [userId], references: [id])
    userId    String
    // @@index([tagId, entryId])
    // @@index([userId, tagId])
    // @@index([userId, entryId])

    @@id([entryId, tagId, userId])
    @@index([tagId])
    @@index([entryId])
    @@index([userId])
}

model Tagging {
    id         Int         @id @default(autoincrement())
    //   TODO: represents tags on documents and feeds
    // TODO: should we seperate this into multiple models — TagsOnFeed, etc?
    tag        Tag         @relation(fields: [tagId], references: [id])
    tagId      Int
    user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId     String
    feed       Feed?       @relation(fields: [feedId], references: [id])
    feedId     Int?
    annotation Annotation? @relation(fields: [annotationId], references: [id])

    annotationId Int?
    bookmark     Bookmark? @relation(fields: [bookmarkId], references: [id])
    bookmarkId   Int?
    // TODO: decide if entry should have tag or if it shold be on bookmark
    // entry        Entry     @relation(fields: [entryId], references: [id])
    // entryId      Int
    // @@unique([entryId, userId, tagId])
    // @@index([entryId])

    // do those make sense?
    // is this wise... in any way?
    @@unique([annotationId, userId, tagId])
    @@unique([bookmarkId, userId, tagId])
    @@unique([feedId, userId, tagId])
    @@index([userId])
    @@index([tagId])
    @@index([feedId])
    @@index([annotationId])
    @@index([userId, tagId])
    @@index([userId, feedId])
    @@index([userId, annotationId])
    @@index([bookmarkId])
    @@map("Taggings")
}

model SmartList {
    id          Int       @id @default(autoincrement())
    name        String    @unique
    filter      Json
    viewOptions Json?
    // conditions SmartListCondition[]
    favorite    Favorite?
}

model User {
    id               String           @id @unique @default(cuid())
    provider_id      String           @unique
    hashed_password  String?
    session          Session[]
    createdAt        DateTime         @default(now())
    updatedAt        DateTime         @updatedAt
    //
    email            String           @unique
    username         String           @unique
    //
    // self relation
    followedBy       User[]           @relation("UserFollows")
    following        User[]           @relation("UserFollows")
    //
    interactions     Interaction[]
    favorites        Favorite[]
    articles         Article[]
    favoriteFolders  FavoriteFolder[]
    collections      Collection[]
    annotations      Annotation[]
    subscriptions    Subscription[]
    documentData     EntryData[]
    stylesheets      Stylesheet[]
    states           State[]          @relation("user")
    default_state    State?           @relation("default_state", references: [id], fields: [default_state_id])
    default_state_id Int?             @unique
    taggings         Tagging[]
    tags             Tag[]
    bookmarks        Bookmark[]
    EntryTag         EntryTag[]
    context          Context[]
    context_nodes    ContextNode[]

    @@map("user")
}

model Session {
    id           String @id @unique
    user_id      String
    expires      BigInt
    idle_expires BigInt
    user         User   @relation(references: [id], fields: [user_id], onDelete: Cascade)

    @@index([user_id])
    @@map("session")
}

model FavoriteFolder {
    id        Int        @id @default(autoincrement())
    name      String
    createdAt DateTime   @default(now())
    updatedAt DateTime   @updatedAt
    userId    String
    user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
    favorites Favorite[]

    @@index([userId])
}

model Favorite {
    //TODO: could also consider making Favorite with a type of favorite vs folder, making parent/child and getting rid of favoritefolder... not sure
    id               Int             @id @default(autoincrement())
    createdAt        DateTime        @default(now())
    updatedAt        DateTime        @updatedAt
    userId           String
    deleted          DateTime?
    user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
    tagId            Int?            @unique
    tag              Tag?            @relation(fields: [tagId], references: [id])
    rssId            Int?            @unique
    rss              Feed?           @relation(fields: [rssId], references: [id])
    smartListId      Int?            @unique
    smartList        SmartList?      @relation(fields: [smartListId], references: [id])
    folder           FavoriteFolder? @relation(fields: [favoriteFolderId], references: [id])
    favoriteFolderId Int?
    annotation       Annotation?     @relation(fields: [annotationId], references: [id])
    annotationId     Int?            @unique
    bookmark         Bookmark?       @relation(fields: [bookmarkId], references: [id])
    bookmarkId       Int?            @unique

    @@index([userId])
    @@index([tagId])
    @@index([rssId])
    @@index([smartListId])
    @@index([bookmarkId])
    @@index([favoriteFolderId])
    @@index([annotationId])
}

//todo: user entry/
model UserEntry {
    id         Int          @id @default(autoincrement())
    // this model connects a user with an entry, storing their own custom metadata
    Stylesheet Stylesheet[]
}

model Stylesheet {
    id          Int        @id @default(autoincrement())
    domain      String
    css         String     @db.MediumText
    entry       UserEntry? @relation(fields: [userEntryId], references: [id])
    userEntryId Int?
    user        User       @relation(fields: [userId], references: [id])
    userId      String

    @@index([userEntryId])
    @@index([userId])
}
