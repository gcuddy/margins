import type { PDFDocumentProxy, TextItem } from "pdfjs-dist/types/src/display/api";
import Canvas from "canvas";
import type { PDFPageProxy } from "pdfjs-dist";
export function parse_annotations(
    pdf: PDFDocumentProxy
) {
    // pdf.annotationStorage.getAll();
}


export async function make_thumbnail(
    pdf: PDFDocumentProxy,
    page_number = 1
): Promise<Buffer> {
    const page = await pdf.getPage(page_number);
    const viewport = page.getViewport({ scale: 1 });
    const canvas = Canvas.createCanvas(viewport.width, viewport.height);
    const context = canvas.getContext("2d");
    await page.render({ canvasContext: context as any, viewport }).promise;
    return canvas.toBuffer();
}

interface MetadataInfo {
    Title?: string
    Author?: string
    CreationDate?: string
    ModDate?: string
    Subject?: string
}

export async function get_pdf_fingerprint(
    pdf: PDFDocumentProxy
) {
    return pdf.fingerprints[0];
}

export async function parse_pdf(
    pdf: PDFDocumentProxy,
    parseText = false
) {
    let text: string | undefined = undefined;
    if (parseText) {
        // todo - see https://github.com/omnivore-app/omnivore/blob/c9fcbe72ddc6f40dd06e7073b8ffe3c1e71bd650/packages/pdf-handler/src/pdf.ts#LL106C14-L106C25
        text = await get_pdf_text(pdf, {
            type: 'text'
        });
    }
    const metadata = await pdf.getMetadata();
    const info = metadata.info as MetadataInfo;
    return {
        title: info.Title,
        author: info.Author,
        text
    }
}

export async function get_pdf_text(
    pdf: PDFDocumentProxy,
    opts: {
        max_pages?: number
        type?: 'html' | 'text'
    } = {
            type: 'html',
            max_pages: undefined
        }
): Promise<string> {
    const pages = read_pdf_text(pdf);
    if (opts.type === 'html') {
        return pages.then(pages_to_html);
    } else {
        return pages.then(pages_to_string);
    }
}

type Page = {
    lines: string[]
}

const pages_to_string = (pages: Page[]) => pages.reduce((accum, page) => accum.concat(page.lines.join('\n') + '\n'), '');

const pages_to_html = (pages: Page[]) => pages.reduce((accum, page, index) => accum.concat(`<div class="page" data-page=${index + 1}>` + page.lines.join('<br/>') + '</div>'), '');

async function read_pdf_text(
    pdf: PDFDocumentProxy,
    max_pages?: number
): Promise<Page[]> {
    const pages: Page[] = [];

    const num_pages = max_pages || pdf.numPages;


    for (let i = 1; i <= num_pages; i++) {
        pages.push(
            await parse_page(await pdf.getPage(i))
        );
    }

    return pages
}

async function parse_page(
    page: PDFPageProxy
): Promise<Page> {
    const raw_content = await page.getTextContent();

    return parse_page_items(
        raw_content.items.filter((item): item is TextItem => 'str' in item)
    )
}


/**
 * via https://github.com/omnivore-app/omnivore/blob/c9fcbe72ddc6f40dd06e7073b8ffe3c1e71bd650/packages/pdf-handler/src/pdf.ts#LL106C14-L106C25
 * Parses individual text items generated by pdf.js This allows lower level control of what actually
 * gets parsed. For example, a consumer of this function may remove entire sections of the pdf text
 * prior to passing items in here. See parsePage function above for example usage.
 *
 * @param pdfItems An array of TextItem items.
 */
const parse_page_items = (pdfItems: TextItem[]): Page => {
    const lineData: { [y: number]: TextItem[] } = {}

    for (let i = 0; i < pdfItems.length; i++) {
        const item = pdfItems[i]
        const y = item.transform[5]
        /* eslint-disable no-prototype-builtins */
        if (!lineData.hasOwnProperty(y)) {
            lineData[y] = []
        }
        lineData[y].push(item)
    }

    const yCoords = Object.keys(lineData)
        .map((key) => Number(key))
        // b - a here because the bottom is y = 0 so we want that to be last
        .sort((a, b) => b - a)
        // insert an empty line between any 2 lines where their distance is greater than the upper line's height
        .reduce((accum: number[], currentY, index, array) => {
            const nextY = array[index + 1]
            if (nextY != undefined) {
                const currentLineHeight: number = lineData[currentY].reduce(
                    (finalValue, current) =>
                        finalValue > current.height ? finalValue : current.height,
                    -1
                )

                // currentY - nextY because currentY will be higher than nextY
                if (Math.floor((currentY - nextY) / currentLineHeight) > 1) {
                    const newY = currentY - currentLineHeight
                    lineData[newY] = []
                    return accum.concat(currentY, newY)
                }
            }
            return accum.concat(currentY)
        }, [])

    const lines: string[] = []
    for (let i = 0; i < yCoords.length; i++) {
        const y = yCoords[i]
        // sort by x position (position in line)
        const lineItems = lineData[y]
            .sort((a, b) => a.transform[4] - b.transform[4])
            .filter((item) => !!item.str)
        let line = lineItems.length ? lineItems[0].str : ''
        for (let j = 1; j < lineItems.length; j++) {
            const item = lineItems[j]
            const lastItem = lineItems[j - 1]
            const xDiff = item.transform[4] - (lastItem.transform[4] + lastItem.width)

            // insert spaces for items that are far apart horizontally
            if (
                item.height !== 0 &&
                (xDiff > item.height || xDiff > lastItem.height)
            ) {
                const spaceCountA = Math.ceil(xDiff / item.height)
                let spaceCount = spaceCountA
                if (lastItem.height !== item.height) {
                    const spaceCountB = Math.ceil(xDiff / lastItem.height)
                    spaceCount = spaceCountA > spaceCountB ? spaceCountA : spaceCountB
                }

                if (isNaN(spaceCount) || isFinite(spaceCount) === false) {
                    spaceCount = 1
                }

                line += Array(spaceCount).fill('').join(' ')
            }
            line += item.str
        }
        lines.push(line)
    }

    return {
        lines,
    }
}


export async function build_toc(pdf: PDFDocumentProxy) {
    const toc = await pdf.getOutline();
    if (!toc) {
        return [];
    }
    const toc_items: TocItem[] = [];
    for (let i = 0; i < toc.length; i++) {
        const item = toc[i];
        toc_items.push({
            title: item.title,
            page: item.dest[0],
            children: await build_toc(pdf)
        })

    }
    return toc_items;

}
